// 1
console.log('start'); //Виводить у консоль "start". Робиться першим.

const promise1 = new Promise((resolve, reject) => { // Створюється promise1.
console.log(1) // Виводиться у консоль "1" під час створення проміса promise1. Робиться другим.
resolve(2) //При успішній роботі має повернути результат "2".
})

promise1.then(res => { //Запускається результат асинхронно
console.log(res) //Запам'ятовує, що має вивести у консоль "2". Робиться четвертим.
})

console.log('end'); //Виводить у консоль "end". Виконується третім.
/*
Виводить:
start
1
end
2
*/


// 2
Promise.resolve(1) //Проміс повертає успішний результат "1".
		.then((x) => x + 1) //До поверненого результату "1" додається 1. Повертаємо у якості успішного результату "2"
		.then((x) => { throw new Error('My Error') }) //Отримаємо "2" і створюємо помилку.
		.catch(() => 1) //Ловимо помилку і у якості успішного результату "1".
		.then((x) => x + 1) //До поверненого результату "1" додається 1. Повертаємо у якості успішного результату "2"
		.then((x) => console.log(x)) //Отримаємо результат "2" і виводимо результат у консоль. Отримаємо "2"
		.catch(console.error) //У випадку "Rejected" виводимо помилку
/*
Виводить: 2
*/


// 3
const promise = new Promise(res => res(2)); //Створюємо проміс який має повертати результат "2"
	promise.then(v => {
	        console.log(v); //Виводимо у консоль отриманий результат "2"
	        return v * 2;  //Множимо результат на два і повертаємо "4"
	    })
	    .then(v => {
	        console.log(v); //Виводимо у консоль отриманий результат "4" 
	        return v * 2;	//Множимо результат на два і повертаємо "8"
	    })
	    .finally(v => {
	        console.log(v);	//Виводимо у консоль v = undefined, так як finally не отримує результат з попереднього then.
	        return v * 2;	// І не впливає на значення яке має приймати наступне then.
	    })
	    .then(v => {
	        console.log(v); //Отримаємо значення "8" з попереднього then і виводимо у консоль "8".
	    });
/*
Виводить:
2
4
undefined
8
*/